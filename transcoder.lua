local a=string.byte;local b=string.char;local c=string.find;local d=string.format;local e=string.gmatch;local f=string.lower;local g=string.sub;local h=math.abs;local i=math.floor;local j=math.frexp;local k=math.ldexp;local tonumber=tonumber;local l={}local m={}local n={}local o={}local p={}local q={}function l:make_getS(r)local s=r;return function()if not s then return nil end;local t=s;s=nil;return t end end;function l:init(u,t,v)if not u then return end;local w={}w.reader=u;w.data=t or""w.name=v;if not t or t==""then w.n=0 else w.n=#t end;w.p=0;return w end;function l:fill(w)local r=w.reader()w.data=r;if not r or r==""then return"EOZ"end;w.n,w.p=#r-1,1;return g(r,1,1)end;function l:zgetc(w)local x,y=w.n,w.p+1;if x>0 then w.n,w.p=x-1,y;return g(w.data,y,y)else return l:fill(w)end end;n.OpMode={iABC=0,iABx=1,iAsBx=2}n.SIZE_C=9;n.SIZE_B=9;n.SIZE_Bx=n.SIZE_C+n.SIZE_B;n.SIZE_A=8;n.SIZE_OP=6;n.POS_OP=0;n.POS_A=n.POS_OP+n.SIZE_OP;n.POS_C=n.POS_A+n.SIZE_A;n.POS_B=n.POS_C+n.SIZE_C;n.POS_Bx=n.POS_C;n.MAXARG_Bx=k(1,n.SIZE_Bx)-1;n.MAXARG_sBx=i(n.MAXARG_Bx/2)n.MAXARG_A=k(1,n.SIZE_A)-1;n.MAXARG_B=k(1,n.SIZE_B)-1;n.MAXARG_C=k(1,n.SIZE_C)-1;function n:GET_OPCODE(z)return n.ROpCode[z.OP]end;function n:SET_OPCODE(z,A)z.OP=n.OpCode[A]end;function n:GETARG_A(z)return z.A end;function n:SETARG_A(z,B)z.A=B end;function n:GETARG_B(z)return z.B end;function n:SETARG_B(z,s)z.B=s end;function n:GETARG_C(z)return z.C end;function n:SETARG_C(z,s)z.C=s end;function n:GETARG_Bx(z)return z.Bx end;function n:SETARG_Bx(z,s)z.Bx=s end;function n:GETARG_sBx(z)return z.Bx-n.MAXARG_sBx end;function n:SETARG_sBx(z,s)z.Bx=s+n.MAXARG_sBx end;function n:CREATE_ABC(A,C,s,D)return{OP=n.OpCode[A],A=C,B=s,C=D}end;function n:CREATE_ABx(A,C,E)return{OP=n.OpCode[A],A=C,Bx=E}end;function n:CREATE_Inst(D)local A=D%64;D=(D-A)/64;local C=D%256;D=(D-C)/256;return n:CREATE_ABx(A,C,D)end;function n:Instruction(z)if z.Bx then z.C=z.Bx%512;z.B=(z.Bx-z.C)/512 end;local F=z.A*64+z.OP;local G=F%256;F=z.C*64+(F-G)/256;local H=F%256;F=z.B*128+(F-H)/256;local I=F%256;local J=(F-I)/256;return b(G,H,I,J)end;function n:DecodeInst(K)local z={}local F=a(K,1)local L=F%64;z.OP=L;F=a(K,2)*4+(F-L)/64;local C=F%256;z.A=C;F=a(K,3)*4+(F-C)/256;local D=F%512;z.C=D;z.B=a(K,4)*2+(F-D)/512;local M=n.OpMode[tonumber(g(n.opmodes[L+1],7,7))]if M~="iABC"then z.Bx=z.B*512+z.C end;return z end;n.BITRK=k(1,n.SIZE_B-1)function n:ISK(K)return K>=n.BITRK end;function n:INDEXK(K)return K-n.BITRK end;n.MAXINDEXRK=n.BITRK-1;function n:RKASK(K)return K+n.BITRK end;n.NO_REG=n.MAXARG_A;n.opnames={}n.OpCode={}n.ROpCode={}local z=0;for N in e([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],"%S+")do local x="OP_"..N;n.opnames[z]=N;n.OpCode[x]=z;n.ROpCode[z]=x;z=z+1 end;n.NUM_OPCODES=z;n.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function n:getOpMode(O)return n.opmodes[n.OpCode[O]]%4 end;function n:getBMode(O)return i(n.opmodes[n.OpCode[O]]/16)%4 end;function n:getCMode(O)return i(n.opmodes[n.OpCode[O]]/4)%4 end;function n:testAMode(O)return i(n.opmodes[n.OpCode[O]]/64)%2 end;function n:testTMode(O)return i(n.opmodes[n.OpCode[O]]/128)end;n.LFIELDS_PER_FLUSH=50;local function M(P,C,s,D,O)return P*128+C*64+n.OpArgMask[s]*16+n.OpArgMask[D]*4+n.OpMode[O]end;n.opmodes={M(0,1,"OpArgK","OpArgN","iABx"),M(0,1,"OpArgU","OpArgU","iABC"),M(0,1,"OpArgR","OpArgN","iABC"),M(0,1,"OpArgU","OpArgN","iABC"),M(0,1,"OpArgK","OpArgN","iABx"),M(0,1,"OpArgR","OpArgK","iABC"),M(0,0,"OpArgK","OpArgN","iABx"),M(0,0,"OpArgU","OpArgN","iABC"),M(0,0,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgU","OpArgU","iABC"),M(0,1,"OpArgR","OpArgK","iABC"),M(0,1,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgK","OpArgK","iABC"),M(0,1,"OpArgR","OpArgN","iABC"),M(0,1,"OpArgR","OpArgN","iABC"),M(0,1,"OpArgR","OpArgN","iABC"),M(0,1,"OpArgR","OpArgR","iABC"),M(0,0,"OpArgR","OpArgN","iAsBx"),M(1,0,"OpArgK","OpArgK","iABC"),M(1,0,"OpArgK","OpArgK","iABC"),M(1,0,"OpArgK","OpArgK","iABC"),M(1,1,"OpArgR","OpArgU","iABC"),M(1,1,"OpArgR","OpArgU","iABC"),M(0,1,"OpArgU","OpArgU","iABC"),M(0,1,"OpArgU","OpArgU","iABC"),M(0,0,"OpArgU","OpArgN","iABC"),M(0,1,"OpArgR","OpArgN","iAsBx"),M(0,1,"OpArgR","OpArgN","iAsBx"),M(1,0,"OpArgN","OpArgU","iABC"),M(0,0,"OpArgU","OpArgU","iABC"),M(0,0,"OpArgN","OpArgN","iABC"),M(0,1,"OpArgU","OpArgN","iABx"),M(0,1,"OpArgU","OpArgN","iABC")}n.opmodes[0]=M(0,1,"OpArgR","OpArgN","iABC")o.RESERVED=[[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]o.MAXSRC=80;o.MAX_INT=2147483645;o.LUA_QS="'%s'"o.LUA_COMPAT_LSTR=1;function o:init()local Q,R={},{}for N in e(o.RESERVED,"[^\n]+")do local S,S,T,U=c(N,"(%S+)%s+(%S+)")Q[T]=U;R[U]=T end;o.tokens=Q;o.enums=R end;function o:chunkid(V,W)local X;local Y=g(V,1,1)if Y=="="then X=g(V,2,W)else if Y=="@"then V=g(V,2)W=W-#" '...' "local Z=#V;X=""if Z>W then V=g(V,1+Z-W)X=X.."..."end;X=X..V else local _=c(V,"[\n\r]")_=_ and _-1 or#V;W=W-#" [string \"...\"] "if _>W then _=W end;X="[string \""if _<#V then X=X..g(V,1,_).."..."else X=X..V end;X=X.."\"]"end end;return X end;function o:token2str(a0,a1)if g(a1,1,3)~="TK_"then if c(a1,"%c")then return d("char(%d)",a(a1))end;return a1 else end;return o.tokens[a1]end;function o:lexerror(a0,a2,a1)local function a3(a0,a1)if a1=="TK_NAME"or a1=="TK_STRING"or a1=="TK_NUMBER"then return a0.buff else return o:token2str(a0,a1)end end;local r=o:chunkid(a0.source,o.MAXSRC)local a2=d("%s:%d: %s",r,a0.linenumber,a2)if a1 then a2=d("%s near "..o.LUA_QS,a2,a3(a0,a1))end;error(a2)end;function o:syntaxerror(a0,a2)o:lexerror(a0,a2,a0.t.token)end;function o:currIsNewline(a0)return a0.current=="\n"or a0.current=="\r"end;function o:inclinenumber(a0)local a4=a0.current;o:nextc(a0)if o:currIsNewline(a0)and a0.current~=a4 then o:nextc(a0)end;a0.linenumber=a0.linenumber+1;if a0.linenumber>=o.MAX_INT then o:syntaxerror(a0,"chunk has too many lines")end end;function o:setinput(a5,a0,w)if not a0 then a0={}end;if not a0.lookahead then a0.lookahead={}end;if not a0.t then a0.t={}end;a0.decpoint="."a0.L=a5;a0.lookahead.token="TK_EOS"a0.z=w;a0.fs=nil;a0.linenumber=1;a0.lastline=1;o:nextc(a0)end;function o:check_next(a0,a6)if not c(a6,a0.current,1,1)then return false end;o:save_and_next(a0)return true end;function o:next(a0)a0.lastline=a0.linenumber;if a0.lookahead.token~="TK_EOS"then a0.t.seminfo=a0.lookahead.seminfo;a0.t.token=a0.lookahead.token;a0.lookahead.token="TK_EOS"else a0.t.token=o:llex(a0,a0.t)end end;function o:lookahead(a0)a0.lookahead.token=o:llex(a0,a0.lookahead)end;function o:nextc(a0)local D=l:zgetc(a0.z)a0.current=D;return D end;function o:save(a0,D)local r=a0.buff;a0.buff=r..D end;function o:save_and_next(a0)o:save(a0,a0.current)return o:nextc(a0)end;function o:str2d(a7)local a8=tonumber(a7)if a8 then return a8 end;if f(g(a7,1,2))=="0x"then a8=tonumber(a7,16)if a8 then return a8 end end;return nil end;function o:buffreplace(a0,a9,aa)local a8,r="",a0.buff;for y=1,#r do local D=g(r,y,y)if D==a9 then D=aa end;a8=a8 ..D end;a0.buff=a8 end;function o:trydecpoint(a0,ab)local a4=a0.decpoint;o:buffreplace(a0,a4,a0.decpoint)local ac=o:str2d(a0.buff)ab.seminfo=ac;if not ac then o:buffreplace(a0,a0.decpoint,".")o:lexerror(a0,"malformed number","TK_NUMBER")end end;function o:read_numeral(a0,ab)repeat o:save_and_next(a0)until c(a0.current,"%D")and a0.current~="."if o:check_next(a0,"Ee")then o:check_next(a0,"+-")end;while c(a0.current,"^%w$")or a0.current=="_"do o:save_and_next(a0)end;o:buffreplace(a0,".",a0.decpoint)local ac=o:str2d(a0.buff)ab.seminfo=ac;if not ac then o:trydecpoint(a0,ab)end end;function o:skip_sep(a0)local ad=0;local a7=a0.current;o:save_and_next(a0)while a0.current=="="do o:save_and_next(a0)ad=ad+1 end;return a0.current==a7 and ad or-ad-1 end;function o:read_long_string(a0,ab,ae)local af=0;o:save_and_next(a0)if o:currIsNewline(a0)then o:inclinenumber(a0)end;while true do local D=a0.current;if D=="EOZ"then o:lexerror(a0,ab and"unfinished long string"or"unfinished long comment","TK_EOS")elseif D=="["then if o.LUA_COMPAT_LSTR then if o:skip_sep(a0)==ae then o:save_and_next(a0)af=af+1;if o.LUA_COMPAT_LSTR==1 then if ae==0 then o:lexerror(a0,"nesting of [[...]] is deprecated","[")end end end end elseif D=="]"then if o:skip_sep(a0)==ae then o:save_and_next(a0)if o.LUA_COMPAT_LSTR and o.LUA_COMPAT_LSTR==2 then af=af-1;if ae==0 and af>=0 then break end end;break end elseif o:currIsNewline(a0)then o:save(a0,"\n")o:inclinenumber(a0)if not ab then a0.buff=""end else if ab then o:save_and_next(a0)else o:nextc(a0)end end end;if ab then local y=3+ae;ab.seminfo=g(a0.buff,y,-y)end end;function o:read_string(a0,ag,ab)o:save_and_next(a0)while a0.current~=ag do local D=a0.current;if D=="EOZ"then o:lexerror(a0,"unfinished string","TK_EOS")elseif o:currIsNewline(a0)then o:lexerror(a0,"unfinished string","TK_STRING")elseif D=="\\"then D=o:nextc(a0)if o:currIsNewline(a0)then o:save(a0,"\n")o:inclinenumber(a0)elseif D~="EOZ"then local z=c("abfnrtv",D,1,1)if z then o:save(a0,g("\a\b\f\n\r\t\v",z,z))o:nextc(a0)elseif not c(D,"%d")then o:save_and_next(a0)else D,z=0,0;repeat D=10*D+a0.current;o:nextc(a0)z=z+1 until z>=3 or not c(a0.current,"%d")if D>255 then o:lexerror(a0,"escape sequence too large","TK_STRING")end;o:save(a0,b(D))end end else o:save_and_next(a0)end end;o:save_and_next(a0)ab.seminfo=g(a0.buff,2,-2)end;function o:llex(a0,ab)a0.buff=""while true do local D=a0.current;if o:currIsNewline(a0)then o:inclinenumber(a0)elseif D=="-"then D=o:nextc(a0)if D~="-"then return"-"end;local ae=-1;if o:nextc(a0)=='['then ae=o:skip_sep(a0)a0.buff=""end;if ae>=0 then o:read_long_string(a0,nil,ae)a0.buff=""else while not o:currIsNewline(a0)and a0.current~="EOZ"do o:nextc(a0)end end elseif D=="["then local ae=o:skip_sep(a0)if ae>=0 then o:read_long_string(a0,ab,ae)return"TK_STRING"elseif ae==-1 then return"["else o:lexerror(a0,"invalid long string delimiter","TK_STRING")end elseif D=="="then D=o:nextc(a0)if D~="="then return"="else o:nextc(a0)return"TK_EQ"end elseif D=="<"then D=o:nextc(a0)if D~="="then return"<"else o:nextc(a0)return"TK_LE"end elseif D==">"then D=o:nextc(a0)if D~="="then return">"else o:nextc(a0)return"TK_GE"end elseif D=="~"then D=o:nextc(a0)if D~="="then return"~"else o:nextc(a0)return"TK_NE"end elseif D=="\""or D=="'"then o:read_string(a0,D,ab)return"TK_STRING"elseif D=="."then D=o:save_and_next(a0)if o:check_next(a0,".")then if o:check_next(a0,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not c(D,"%d")then return"."else o:read_numeral(a0,ab)return"TK_NUMBER"end elseif D=="EOZ"then return"TK_EOS"else if c(D,"%s")then o:nextc(a0)elseif c(D,"%d")then o:read_numeral(a0,ab)return"TK_NUMBER"elseif c(D,"[_%a]")then repeat D=o:save_and_next(a0)until D=="EOZ"or not c(D,"[_%w]")local ah=a0.buff;local T=o.enums[ah]if T then return T end;ab.seminfo=ah;return"TK_NAME"else o:nextc(a0)return D end end end end;p.MAXSTACK=250;function p:ttisnumber(A)if A then return type(A.value)=="number"else return false end end;function p:nvalue(A)return A.value end;function p:setnilvalue(A)A.value=nil end;function p:setsvalue(A,K)A.value=K end;p.setnvalue=p.setsvalue;p.sethvalue=p.setsvalue;p.setbvalue=p.setsvalue;function p:numadd(C,s)return C+s end;function p:numsub(C,s)return C-s end;function p:nummul(C,s)return C*s end;function p:numdiv(C,s)return C/s end;function p:nummod(C,s)return C%s end;function p:numpow(C,s)return C^s end;function p:numunm(C)return-C end;function p:numisnan(C)return not C==C end;p.NO_JUMP=-1;p.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}p.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function p:getcode(ai,aj)return ai.f.code[aj.info]end;function p:codeAsBx(ai,A,ak,al)return p:codeABx(ai,A,ak,al+n.MAXARG_sBx)end;function p:setmultret(ai,aj)p:setreturns(ai,aj,m.LUA_MULTRET)end;function p:hasjumps(aj)return aj.t~=aj.f end;function p:isnumeral(aj)return aj.k=="VKNUM"and aj.t==p.NO_JUMP and aj.f==p.NO_JUMP end;function p:_nil(ai,a9,x)if ai.pc>ai.lasttarget then if ai.pc==0 then if a9>=ai.nactvar then return end else local am=ai.f.code[ai.pc-1]if n:GET_OPCODE(am)=="OP_LOADNIL"then local an=n:GETARG_A(am)local ao=n:GETARG_B(am)if an<=a9 and a9<=ao+1 then if a9+x-1>ao then n:SETARG_B(am,a9+x-1)end;return end end end end;p:codeABC(ai,"OP_LOADNIL",a9,a9+x-1,0)end;function p:jump(ai)local ap=ai.jpc;ai.jpc=p.NO_JUMP;local aq=p:codeAsBx(ai,"OP_JMP",0,p.NO_JUMP)aq=p:concat(ai,aq,ap)return aq end;function p:ret(ai,Y,ar)p:codeABC(ai,"OP_RETURN",Y,ar+1,0)end;function p:condjump(ai,L,ak,as,at)p:codeABC(ai,L,ak,as,at)return p:jump(ai)end;function p:fixjump(ai,au,av)local aw=ai.f.code[au]local ax=av-(au+1)assert(av~=p.NO_JUMP)if h(ax)>n.MAXARG_sBx then o:syntaxerror(ai.ls,"control structure too long")end;n:SETARG_sBx(aw,ax)end;function p:getlabel(ai)ai.lasttarget=ai.pc;return ai.pc end;function p:getjump(ai,au)local ax=n:GETARG_sBx(ai.f.code[au])if ax==p.NO_JUMP then return p.NO_JUMP else return au+1+ax end end;function p:getjumpcontrol(ai,au)local ay=ai.f.code[au]local az=ai.f.code[au-1]if au>=1 and n:testTMode(n:GET_OPCODE(az))~=0 then return az else return ay end end;function p:need_value(ai,aA)while aA~=p.NO_JUMP do local z=p:getjumpcontrol(ai,aA)if n:GET_OPCODE(z)~="OP_TESTSET"then return true end;aA=p:getjump(ai,aA)end;return false end;function p:patchtestreg(ai,aB,aC)local z=p:getjumpcontrol(ai,aB)if n:GET_OPCODE(z)~="OP_TESTSET"then return false end;if aC~=n.NO_REG and aC~=n:GETARG_B(z)then n:SETARG_A(z,aC)else n:SET_OPCODE(z,"OP_TEST")local s=n:GETARG_B(z)n:SETARG_A(z,s)n:SETARG_B(z,0)end;return true end;function p:removevalues(ai,aA)while aA~=p.NO_JUMP do p:patchtestreg(ai,aA,n.NO_REG)aA=p:getjump(ai,aA)end end;function p:patchlistaux(ai,aA,aD,aC,aE)while aA~=p.NO_JUMP do local aF=p:getjump(ai,aA)if p:patchtestreg(ai,aA,aC)then p:fixjump(ai,aA,aD)else p:fixjump(ai,aA,aE)end;aA=aF end end;function p:dischargejpc(ai)p:patchlistaux(ai,ai.jpc,ai.pc,n.NO_REG,ai.pc)ai.jpc=p.NO_JUMP end;function p:patchlist(ai,aA,aG)if aG==ai.pc then p:patchtohere(ai,aA)else assert(aG<ai.pc)p:patchlistaux(ai,aA,aG,n.NO_REG,aG)end end;function p:patchtohere(ai,aA)p:getlabel(ai)ai.jpc=p:concat(ai,ai.jpc,aA)end;function p:concat(ai,aH,aI)if aI==p.NO_JUMP then return aH elseif aH==p.NO_JUMP then return aI else local aA=aH;local aF=p:getjump(ai,aA)while aF~=p.NO_JUMP do aA=aF;aF=p:getjump(ai,aA)end;p:fixjump(ai,aA,aI)end;return aH end;function p:checkstack(ai,x)local aJ=ai.freereg+x;if aJ>ai.f.maxstacksize then if aJ>=p.MAXSTACK then o:syntaxerror(ai.ls,"function or expression too complex")end;ai.f.maxstacksize=aJ end end;function p:reserveregs(ai,x)p:checkstack(ai,x)ai.freereg=ai.freereg+x end;function p:freereg(ai,aC)if not n:ISK(aC)and aC>=ai.nactvar then ai.freereg=ai.freereg-1;assert(aC==ai.freereg)end end;function p:freeexp(ai,aj)if aj.k=="VNONRELOC"then p:freereg(ai,aj.info)end end;function p:addk(ai,aK,N)local a5=ai.L;local aL=ai.h[aK.value]local aM=ai.f;if p:ttisnumber(aL)then return p:nvalue(aL)else aL={}p:setnvalue(aL,ai.nk)ai.h[aK.value]=aL;m:growvector(a5,aM.k,ai.nk,aM.sizek,nil,n.MAXARG_Bx,"constant table overflow")aM.k[ai.nk]=N;local aN=ai.nk;ai.nk=ai.nk+1;return aN end end;function p:stringK(ai,a7)local A={}p:setsvalue(A,a7)return p:addk(ai,A,A)end;function p:numberK(ai,aO)local A={}p:setnvalue(A,aO)return p:addk(ai,A,A)end;function p:boolK(ai,s)local A={}p:setbvalue(A,s)return p:addk(ai,A,A)end;function p:nilK(ai)local aK,N={},{}p:setnilvalue(N)p:sethvalue(aK,ai.h)return p:addk(ai,aK,N)end;function p:setreturns(ai,aj,aP)if aj.k=="VCALL"then n:SETARG_C(p:getcode(ai,aj),aP+1)elseif aj.k=="VVARARG"then n:SETARG_B(p:getcode(ai,aj),aP+1)n:SETARG_A(p:getcode(ai,aj),ai.freereg)p:reserveregs(ai,1)end end;function p:setoneret(ai,aj)if aj.k=="VCALL"then aj.k="VNONRELOC"aj.info=n:GETARG_A(p:getcode(ai,aj))elseif aj.k=="VVARARG"then n:SETARG_B(p:getcode(ai,aj),2)aj.k="VRELOCABLE"end end;function p:dischargevars(ai,aj)local aK=aj.k;if aK=="VLOCAL"then aj.k="VNONRELOC"elseif aK=="VUPVAL"then aj.info=p:codeABC(ai,"OP_GETUPVAL",0,aj.info,0)aj.k="VRELOCABLE"elseif aK=="VGLOBAL"then aj.info=p:codeABx(ai,"OP_GETGLOBAL",0,aj.info)aj.k="VRELOCABLE"elseif aK=="VINDEXED"then p:freereg(ai,aj.aux)p:freereg(ai,aj.info)aj.info=p:codeABC(ai,"OP_GETTABLE",0,aj.info,aj.aux)aj.k="VRELOCABLE"elseif aK=="VVARARG"or aK=="VCALL"then p:setoneret(ai,aj)else end end;function p:code_label(ai,ak,s,aQ)p:getlabel(ai)return p:codeABC(ai,"OP_LOADBOOL",ak,s,aQ)end;function p:discharge2reg(ai,aj,aC)p:dischargevars(ai,aj)local aK=aj.k;if aK=="VNIL"then p:_nil(ai,aC,1)elseif aK=="VFALSE"or aK=="VTRUE"then p:codeABC(ai,"OP_LOADBOOL",aC,aj.k=="VTRUE"and 1 or 0,0)elseif aK=="VK"then p:codeABx(ai,"OP_LOADK",aC,aj.info)elseif aK=="VKNUM"then p:codeABx(ai,"OP_LOADK",aC,p:numberK(ai,aj.nval))elseif aK=="VRELOCABLE"then local au=p:getcode(ai,aj)n:SETARG_A(au,aC)elseif aK=="VNONRELOC"then if aC~=aj.info then p:codeABC(ai,"OP_MOVE",aC,aj.info,0)end else assert(aj.k=="VVOID"or aj.k=="VJMP")return end;aj.info=aC;aj.k="VNONRELOC"end;function p:discharge2anyreg(ai,aj)if aj.k~="VNONRELOC"then p:reserveregs(ai,1)p:discharge2reg(ai,aj,ai.freereg-1)end end;function p:exp2reg(ai,aj,aC)p:discharge2reg(ai,aj,aC)if aj.k=="VJMP"then aj.t=p:concat(ai,aj.t,aj.info)end;if p:hasjumps(aj)then local aR;local aS=p.NO_JUMP;local aT=p.NO_JUMP;if p:need_value(ai,aj.t)or p:need_value(ai,aj.f)then local aU=aj.k=="VJMP"and p.NO_JUMP or p:jump(ai)aS=p:code_label(ai,aC,0,1)aT=p:code_label(ai,aC,1,0)p:patchtohere(ai,aU)end;aR=p:getlabel(ai)p:patchlistaux(ai,aj.f,aR,aC,aS)p:patchlistaux(ai,aj.t,aR,aC,aT)end;aj.f,aj.t=p.NO_JUMP,p.NO_JUMP;aj.info=aC;aj.k="VNONRELOC"end;function p:exp2nextreg(ai,aj)p:dischargevars(ai,aj)p:freeexp(ai,aj)p:reserveregs(ai,1)p:exp2reg(ai,aj,ai.freereg-1)end;function p:exp2anyreg(ai,aj)p:dischargevars(ai,aj)if aj.k=="VNONRELOC"then if not p:hasjumps(aj)then return aj.info end;if aj.info>=ai.nactvar then p:exp2reg(ai,aj,aj.info)return aj.info end end;p:exp2nextreg(ai,aj)return aj.info end;function p:exp2val(ai,aj)if p:hasjumps(aj)then p:exp2anyreg(ai,aj)else p:dischargevars(ai,aj)end end;function p:exp2RK(ai,aj)p:exp2val(ai,aj)local aK=aj.k;if aK=="VKNUM"or aK=="VTRUE"or aK=="VFALSE"or aK=="VNIL"then if ai.nk<=n.MAXINDEXRK then if aj.k=="VNIL"then aj.info=p:nilK(ai)else aj.info=aj.k=="VKNUM"and p:numberK(ai,aj.nval)or p:boolK(ai,aj.k=="VTRUE")end;aj.k="VK"return n:RKASK(aj.info)end elseif aK=="VK"then if aj.info<=n.MAXINDEXRK then return n:RKASK(aj.info)end else end;return p:exp2anyreg(ai,aj)end;function p:storevar(ai,aV,aW)local aK=aV.k;if aK=="VLOCAL"then p:freeexp(ai,aW)p:exp2reg(ai,aW,aV.info)return elseif aK=="VUPVAL"then local aj=p:exp2anyreg(ai,aW)p:codeABC(ai,"OP_SETUPVAL",aj,aV.info,0)elseif aK=="VGLOBAL"then local aj=p:exp2anyreg(ai,aW)p:codeABx(ai,"OP_SETGLOBAL",aj,aV.info)elseif aK=="VINDEXED"then local aj=p:exp2RK(ai,aW)p:codeABC(ai,"OP_SETTABLE",aV.info,aV.aux,aj)else assert(0)end;p:freeexp(ai,aW)end;function p:_self(ai,aj,aX)p:exp2anyreg(ai,aj)p:freeexp(ai,aj)local aY=ai.freereg;p:reserveregs(ai,2)p:codeABC(ai,"OP_SELF",aY,aj.info,p:exp2RK(ai,aX))p:freeexp(ai,aX)aj.info=aY;aj.k="VNONRELOC"end;function p:invertjump(ai,aj)local au=p:getjumpcontrol(ai,aj.info)assert(n:testTMode(n:GET_OPCODE(au))~=0 and n:GET_OPCODE(au)~="OP_TESTSET"and n:GET_OPCODE(au)~="OP_TEST")n:SETARG_A(au,n:GETARG_A(au)==0 and 1 or 0)end;function p:jumponcond(ai,aj,aZ)if aj.k=="VRELOCABLE"then local a_=p:getcode(ai,aj)if n:GET_OPCODE(a_)=="OP_NOT"then ai.pc=ai.pc-1;return p:condjump(ai,"OP_TEST",n:GETARG_B(a_),0,aZ and 0 or 1)end end;p:discharge2anyreg(ai,aj)p:freeexp(ai,aj)return p:condjump(ai,"OP_TESTSET",n.NO_REG,aj.info,aZ and 1 or 0)end;function p:goiftrue(ai,aj)local au;p:dischargevars(ai,aj)local aK=aj.k;if aK=="VK"or aK=="VKNUM"or aK=="VTRUE"then au=p.NO_JUMP elseif aK=="VFALSE"then au=p:jump(ai)elseif aK=="VJMP"then p:invertjump(ai,aj)au=aj.info else au=p:jumponcond(ai,aj,false)end;aj.f=p:concat(ai,aj.f,au)p:patchtohere(ai,aj.t)aj.t=p.NO_JUMP end;function p:goiffalse(ai,aj)local au;p:dischargevars(ai,aj)local aK=aj.k;if aK=="VNIL"or aK=="VFALSE"then au=p.NO_JUMP elseif aK=="VTRUE"then au=p:jump(ai)elseif aK=="VJMP"then au=aj.info else au=p:jumponcond(ai,aj,true)end;aj.t=p:concat(ai,aj.t,au)p:patchtohere(ai,aj.f)aj.f=p.NO_JUMP end;function p:codenot(ai,aj)p:dischargevars(ai,aj)local aK=aj.k;if aK=="VNIL"or aK=="VFALSE"then aj.k="VTRUE"elseif aK=="VK"or aK=="VKNUM"or aK=="VTRUE"then aj.k="VFALSE"elseif aK=="VJMP"then p:invertjump(ai,aj)elseif aK=="VRELOCABLE"or aK=="VNONRELOC"then p:discharge2anyreg(ai,aj)p:freeexp(ai,aj)aj.info=p:codeABC(ai,"OP_NOT",0,aj.info,0)aj.k="VRELOCABLE"else assert(0)end;aj.f,aj.t=aj.t,aj.f;p:removevalues(ai,aj.f)p:removevalues(ai,aj.t)end;function p:indexed(ai,P,aK)P.aux=p:exp2RK(ai,aK)P.k="VINDEXED"end;function p:constfolding(L,b0,b1)local aO;if not p:isnumeral(b0)or not p:isnumeral(b1)then return false end;local b2=b0.nval;local b3=b1.nval;if L=="OP_ADD"then aO=p:numadd(b2,b3)elseif L=="OP_SUB"then aO=p:numsub(b2,b3)elseif L=="OP_MUL"then aO=p:nummul(b2,b3)elseif L=="OP_DIV"then if b3==0 then return false end;aO=p:numdiv(b2,b3)elseif L=="OP_MOD"then if b3==0 then return false end;aO=p:nummod(b2,b3)elseif L=="OP_POW"then aO=p:numpow(b2,b3)elseif L=="OP_UNM"then aO=p:numunm(b2)elseif L=="OP_LEN"then return false else assert(0)aO=0 end;if p:numisnan(aO)then return false end;b0.nval=aO;return true end;function p:codearith(ai,L,b0,b1)if p:constfolding(L,b0,b1)then return else local b4=L~="OP_UNM"and L~="OP_LEN"and p:exp2RK(ai,b1)or 0;local b5=p:exp2RK(ai,b0)if b5>b4 then p:freeexp(ai,b0)p:freeexp(ai,b1)else p:freeexp(ai,b1)p:freeexp(ai,b0)end;b0.info=p:codeABC(ai,L,0,b5,b4)b0.k="VRELOCABLE"end end;function p:codecomp(ai,L,aZ,b0,b1)local b5=p:exp2RK(ai,b0)local b4=p:exp2RK(ai,b1)p:freeexp(ai,b1)p:freeexp(ai,b0)if aZ==0 and L~="OP_EQ"then b5,b4=b4,b5;aZ=1 end;b0.info=p:condjump(ai,L,aZ,b5,b4)b0.k="VJMP"end;function p:prefix(ai,L,aj)local b1={}b1.t,b1.f=p.NO_JUMP,p.NO_JUMP;b1.k="VKNUM"b1.nval=0;if L=="OPR_MINUS"then if not p:isnumeral(aj)then p:exp2anyreg(ai,aj)end;p:codearith(ai,"OP_UNM",aj,b1)elseif L=="OPR_NOT"then p:codenot(ai,aj)elseif L=="OPR_LEN"then p:exp2anyreg(ai,aj)p:codearith(ai,"OP_LEN",aj,b1)else assert(0)end end;function p:infix(ai,L,N)if L=="OPR_AND"then p:goiftrue(ai,N)elseif L=="OPR_OR"then p:goiffalse(ai,N)elseif L=="OPR_CONCAT"then p:exp2nextreg(ai,N)elseif L=="OPR_ADD"or L=="OPR_SUB"or L=="OPR_MUL"or L=="OPR_DIV"or L=="OPR_MOD"or L=="OPR_POW"then if not p:isnumeral(N)then p:exp2RK(ai,N)end else p:exp2RK(ai,N)end end;p.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}p.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}p.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function p:posfix(ai,L,b0,b1)local function b6(b0,b1)b0.k=b1.k;b0.info=b1.info;b0.aux=b1.aux;b0.nval=b1.nval;b0.t=b1.t;b0.f=b1.f end;if L=="OPR_AND"then assert(b0.t==p.NO_JUMP)p:dischargevars(ai,b1)b1.f=p:concat(ai,b1.f,b0.f)b6(b0,b1)elseif L=="OPR_OR"then assert(b0.f==p.NO_JUMP)p:dischargevars(ai,b1)b1.t=p:concat(ai,b1.t,b0.t)b6(b0,b1)elseif L=="OPR_CONCAT"then p:exp2val(ai,b1)if b1.k=="VRELOCABLE"and n:GET_OPCODE(p:getcode(ai,b1))=="OP_CONCAT"then assert(b0.info==n:GETARG_B(p:getcode(ai,b1))-1)p:freeexp(ai,b0)n:SETARG_B(p:getcode(ai,b1),b0.info)b0.k="VRELOCABLE"b0.info=b1.info else p:exp2nextreg(ai,b1)p:codearith(ai,"OP_CONCAT",b0,b1)end else local b7=p.arith_op[L]if b7 then p:codearith(ai,b7,b0,b1)else local b8=p.comp_op[L]if b8 then p:codecomp(ai,b8,p.comp_cond[L],b0,b1)else assert(0)end end end end;function p:fixline(ai,b9)ai.f.lineinfo[ai.pc-1]=b9 end;function p:code(ai,z,b9)local aM=ai.f;p:dischargejpc(ai)m:growvector(ai.L,aM.code,ai.pc,aM.sizecode,nil,m.MAX_INT,"code size overflow")aM.code[ai.pc]=z;m:growvector(ai.L,aM.lineinfo,ai.pc,aM.sizelineinfo,nil,m.MAX_INT,"code size overflow")aM.lineinfo[ai.pc]=b9;local au=ai.pc;ai.pc=ai.pc+1;return au end;function p:codeABC(ai,A,C,s,D)assert(n:getOpMode(A)==n.OpMode.iABC)assert(n:getBMode(A)~=n.OpArgMask.OpArgN or s==0)assert(n:getCMode(A)~=n.OpArgMask.OpArgN or D==0)return p:code(ai,n:CREATE_ABC(A,C,s,D),ai.ls.lastline)end;function p:codeABx(ai,A,C,E)assert(n:getOpMode(A)==n.OpMode.iABx or n:getOpMode(A)==n.OpMode.iAsBx)assert(n:getCMode(A)==n.OpArgMask.OpArgN)return p:code(ai,n:CREATE_ABx(A,C,E),ai.ls.lastline)end;function p:setlist(ai,ba,bb,bc)local D=i((bb-1)/n.LFIELDS_PER_FLUSH)+1;local s=bc==m.LUA_MULTRET and 0 or bc;assert(bc~=0)if D<=n.MAXARG_C then p:codeABC(ai,"OP_SETLIST",ba,s,D)else p:codeABC(ai,"OP_SETLIST",ba,s,0)p:code(ai,n:CREATE_Inst(D),ai.ls.lastline)end;ai.freereg=ba+1 end;q.LUA_SIGNATURE="\27Lua"q.LUA_TNUMBER=3;q.LUA_TSTRING=4;q.LUA_TNIL=0;q.LUA_TBOOLEAN=1;q.LUA_TNONE=-1;q.LUAC_VERSION=0x51;q.LUAC_FORMAT=0;q.LUAC_HEADERSIZE=12;function q:make_setS()local r={}r.data=""local bd=function(a7,r)if not a7 then return 0 end;r.data=r.data..a7;return 0 end;return bd,r end;function q:ttype(A)local be=type(A.value)if be=="number"then return q.LUA_TNUMBER elseif be=="string"then return q.LUA_TSTRING elseif be=="nil"then return q.LUA_TNIL elseif be=="boolean"then return q.LUA_TBOOLEAN else return q.LUA_TNONE end end;function q:from_double(K)local function bf(N)local D=N%256;return(N-D)/256,b(D)end;local bg=0;if K<0 then bg=1;K=-K end;local bh,bi=j(K)if K==0 then bh,bi=0,0 elseif K==1/0 then bh,bi=0,2047 else bh=(bh*2-1)*k(0.5,53)bi=bi+1022 end;local N,bj="",""K=i(bh)for z=1,6 do K,bj=bf(K)N=N..bj end;K,bj=bf(bi*16+K)N=N..bj;K,bj=bf(bg*128+K)N=N..bj;return N end;function q:from_int(K)local N=""K=i(K)if K<0 then K=4294967296+K end;for z=1,4 do local D=K%256;N=N..b(D)K=i(K/256)end;return N end;function q:DumpBlock(s,bk)if bk.status==0 then bk.status=bk.write(s,bk.data)end end;function q:DumpChar(bl,bk)q:DumpBlock(b(bl),bk)end;function q:DumpInt(K,bk)q:DumpBlock(q:from_int(K),bk)end;function q:DumpNumber(K,bk)q:DumpBlock(q:from_double(K),bk)end;function q:DumpString(a7,bk)if a7==nil then q:DumpInt(0,bk)else a7=a7 .."\0"q:DumpInt(#a7,bk)q:DumpBlock(a7,bk)end end;function q:DumpCode(aM,bk)local x=aM.sizecode;q:DumpInt(x,bk)for z=0,x-1 do q:DumpBlock(n:Instruction(aM.code[z]),bk)end end;function q:DumpConstants(aM,bk)local x=aM.sizek;q:DumpInt(x,bk)for z=0,x-1 do local A=aM.k[z]local be=q:ttype(A)q:DumpChar(be,bk)if be==q.LUA_TNIL then elseif be==q.LUA_TBOOLEAN then q:DumpChar(A.value and 1 or 0,bk)elseif be==q.LUA_TNUMBER then q:DumpNumber(A.value,bk)elseif be==q.LUA_TSTRING then q:DumpString(A.value,bk)else end end;x=aM.sizep;q:DumpInt(x,bk)for z=0,x-1 do q:DumpFunction(aM.p[z],aM.source,bk)end end;function q:DumpDebug(aM,bk)local x;x=bk.strip and 0 or aM.sizelineinfo;q:DumpInt(x,bk)for z=0,x-1 do q:DumpInt(aM.lineinfo[z],bk)end;x=bk.strip and 0 or aM.sizelocvars;q:DumpInt(x,bk)for z=0,x-1 do q:DumpString(aM.locvars[z].varname,bk)q:DumpInt(aM.locvars[z].startpc,bk)q:DumpInt(aM.locvars[z].endpc,bk)end;x=bk.strip and 0 or aM.sizeupvalues;q:DumpInt(x,bk)for z=0,x-1 do q:DumpString(aM.upvalues[z],bk)end end;function q:DumpFunction(aM,y,bk)local V=aM.source;if V==y or bk.strip then V=nil end;q:DumpString(V,bk)q:DumpInt(aM.lineDefined,bk)q:DumpInt(aM.lastlinedefined,bk)q:DumpChar(aM.nups,bk)q:DumpChar(aM.numparams,bk)q:DumpChar(aM.is_vararg,bk)q:DumpChar(aM.maxstacksize,bk)q:DumpCode(aM,bk)q:DumpConstants(aM,bk)q:DumpDebug(aM,bk)end;function q:DumpHeader(bk)local bm=q:header()assert(#bm==q.LUAC_HEADERSIZE)q:DumpBlock(bm,bk)end;function q:header()local K=1;return q.LUA_SIGNATURE..b(q.LUAC_VERSION,q.LUAC_FORMAT,K,4,4,4,8,0)end;function q:dump(a5,aM,bn,t,bo)local bk={}bk.L=a5;bk.write=bn;bk.data=t;bk.strip=bo;bk.status=0;q:DumpHeader(bk)q:DumpFunction(aM,nil,bk)bk.write(nil,bk.data)return bk.status end;m.LUA_QS=o.LUA_QS or"'%s'"m.SHRT_MAX=32767;m.LUAI_MAXVARS=200;m.LUAI_MAXUPVALUES=60;m.MAX_INT=o.MAX_INT or 2147483645;m.LUAI_MAXCCALLS=200;m.VARARG_HASARG=1;m.HASARG_MASK=2;m.VARARG_ISVARARG=2;m.VARARG_NEEDSARG=4;m.LUA_MULTRET=-1;function m:LUA_QL(K)return"'"..K.."'"end;function m:growvector(a5,N,bb,bp,P,bq,aj)if bb>=bq then error(aj)end end;function m:newproto(a5)local aM={}aM.k={}aM.sizek=0;aM.p={}aM.sizep=0;aM.code={}aM.sizecode=0;aM.sizelineinfo=0;aM.sizeupvalues=0;aM.nups=0;aM.upvalues={}aM.numparams=0;aM.is_vararg=0;aM.maxstacksize=0;aM.lineinfo={}aM.sizelocvars=0;aM.locvars={}aM.lineDefined=0;aM.lastlinedefined=0;aM.source=nil;return aM end;function m:int2fb(K)local aj=0;while K>=16 do K=i((K+1)/2)aj=aj+1 end;if K<8 then return K else return(aj+1)*8+K-8 end end;function m:hasmultret(aK)return aK=="VCALL"or aK=="VVARARG"end;function m:getlocvar(ai,z)return ai.f.locvars[ai.actvar[z]]end;function m:checklimit(ai,N,Z,O)if N>Z then m:errorlimit(ai,Z,O)end end;function m:anchor_token(a0)if a0.t.token=="TK_NAME"or a0.t.token=="TK_STRING"then end end;function m:error_expected(a0,a1)o:syntaxerror(a0,d(m.LUA_QS.." expected",o:token2str(a0,a1)))end;function m:errorlimit(ai,bq,br)local a2=ai.f.linedefined==0 and d("main function has more than %d %s",bq,br)or d("function at line %d has more than %d %s",ai.f.linedefined,bq,br)o:lexerror(ai.ls,a2,0)end;function m:testnext(a0,D)if a0.t.token==D then o:next(a0)return true else return false end end;function m:check(a0,D)if a0.t.token~=D then m:error_expected(a0,D)end end;function m:checknext(a0,D)m:check(a0,D)o:next(a0)end;function m:check_condition(a0,D,a2)if not D then o:syntaxerror(a0,a2)end end;function m:check_match(a0,br,bs,bt)if not m:testnext(a0,br)then if bt==a0.linenumber then m:error_expected(a0,br)else o:syntaxerror(a0,d(m.LUA_QS.." expected (to close "..m.LUA_QS.." at line %d)",o:token2str(a0,br),o:token2str(a0,bs),bt))end end end;function m:str_checkname(a0)m:check(a0,"TK_NAME")local ah=a0.t.seminfo;o:next(a0)return ah end;function m:init_exp(aj,aK,z)aj.f,aj.t=p.NO_JUMP,p.NO_JUMP;aj.k=aK;aj.info=z end;function m:codestring(a0,aj,a7)m:init_exp(aj,"VK",p:stringK(a0.fs,a7))end;function m:checkname(a0,aj)m:codestring(a0,aj,m:str_checkname(a0))end;function m:registerlocalvar(a0,bu)local ai=a0.fs;local aM=ai.f;m:growvector(a0.L,aM.locvars,ai.nlocvars,aM.sizelocvars,nil,m.SHRT_MAX,"too many local variables")aM.locvars[ai.nlocvars]={}aM.locvars[ai.nlocvars].varname=bu;local bv=ai.nlocvars;ai.nlocvars=ai.nlocvars+1;return bv end;function m:new_localvarliteral(a0,N,x)m:new_localvar(a0,N,x)end;function m:new_localvar(a0,v,x)local ai=a0.fs;m:checklimit(ai,ai.nactvar+x+1,m.LUAI_MAXVARS,"local variables")ai.actvar[ai.nactvar+x]=m:registerlocalvar(a0,v)end;function m:adjustlocalvars(a0,bw)local ai=a0.fs;ai.nactvar=ai.nactvar+bw;for z=bw,1,-1 do m:getlocvar(ai,ai.nactvar-z).startpc=ai.pc end end;function m:removevars(a0,bx)local ai=a0.fs;while ai.nactvar>bx do ai.nactvar=ai.nactvar-1;m:getlocvar(ai,ai.nactvar).endpc=ai.pc end end;function m:indexupvalue(ai,v,N)local aM=ai.f;for z=0,aM.nups-1 do if ai.upvalues[z].k==N.k and ai.upvalues[z].info==N.info then assert(aM.upvalues[z]==v)return z end end;m:checklimit(ai,aM.nups+1,m.LUAI_MAXUPVALUES,"upvalues")m:growvector(ai.L,aM.upvalues,aM.nups,aM.sizeupvalues,nil,m.MAX_INT,"")aM.upvalues[aM.nups]=v;assert(N.k=="VLOCAL"or N.k=="VUPVAL")ai.upvalues[aM.nups]={k=N.k,info=N.info}local by=aM.nups;aM.nups=aM.nups+1;return by end;function m:searchvar(ai,x)for z=ai.nactvar-1,0,-1 do if x==m:getlocvar(ai,z).varname then return z end end;return-1 end;function m:markupval(ai,bz)local bA=ai.bl;while bA and bA.nactvar>bz do bA=bA.previous end;if bA then bA.upval=true end end;function m:singlevaraux(ai,x,aV,ba)if ai==nil then m:init_exp(aV,"VGLOBAL",n.NO_REG)return"VGLOBAL"else local N=m:searchvar(ai,x)if N>=0 then m:init_exp(aV,"VLOCAL",N)if ba==0 then m:markupval(ai,N)end;return"VLOCAL"else if m:singlevaraux(ai.prev,x,aV,0)=="VGLOBAL"then return"VGLOBAL"end;aV.info=m:indexupvalue(ai,x,aV)aV.k="VUPVAL"return"VUPVAL"end end end;function m:singlevar(a0,aV)local bu=m:str_checkname(a0)local ai=a0.fs;if m:singlevaraux(ai,bu,aV,1)=="VGLOBAL"then aV.info=p:stringK(ai,bu)end end;function m:adjust_assign(a0,bw,bB,aj)local ai=a0.fs;local bC=bw-bB;if m:hasmultret(aj.k)then bC=bC+1;if bC<=0 then bC=0 end;p:setreturns(ai,aj,bC)if bC>1 then p:reserveregs(ai,bC-1)end else if aj.k~="VVOID"then p:exp2nextreg(ai,aj)end;if bC>0 then local aC=ai.freereg;p:reserveregs(ai,bC)p:_nil(ai,aC,bC)end end end;function m:enterlevel(a0)a0.L.nCcalls=a0.L.nCcalls+1;if a0.L.nCcalls>m.LUAI_MAXCCALLS then o:lexerror(a0,"chunk has too many syntax levels",0)end end;function m:leavelevel(a0)a0.L.nCcalls=a0.L.nCcalls-1 end;function m:enterblock(ai,bA,bD)bA.breaklist=p.NO_JUMP;bA.isbreakable=bD;bA.nactvar=ai.nactvar;bA.upval=false;bA.previous=ai.bl;ai.bl=bA;assert(ai.freereg==ai.nactvar)end;function m:leaveblock(ai)local bA=ai.bl;ai.bl=bA.previous;m:removevars(ai.ls,bA.nactvar)if bA.upval then p:codeABC(ai,"OP_CLOSE",bA.nactvar,0,0)end;assert(not bA.isbreakable or not bA.upval)assert(bA.nactvar==ai.nactvar)ai.freereg=ai.nactvar;p:patchtohere(ai,bA.breaklist)end;function m:pushclosure(a0,aY,N)local ai=a0.fs;local aM=ai.f;m:growvector(a0.L,aM.p,ai.np,aM.sizep,nil,n.MAXARG_Bx,"constant table overflow")aM.p[ai.np]=aY.f;ai.np=ai.np+1;m:init_exp(N,"VRELOCABLE",p:codeABx(ai,"OP_CLOSURE",0,ai.np-1))for z=0,aY.f.nups-1 do local A=aY.upvalues[z].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"p:codeABC(ai,A,0,aY.upvalues[z].info,0)end end;function m:open_func(a0,ai)local a5=a0.L;local aM=m:newproto(a0.L)ai.f=aM;ai.prev=a0.fs;ai.ls=a0;ai.L=a5;a0.fs=ai;ai.pc=0;ai.lasttarget=-1;ai.jpc=p.NO_JUMP;ai.freereg=0;ai.nk=0;ai.np=0;ai.nlocvars=0;ai.nactvar=0;ai.bl=nil;aM.maxstacksize=2;ai.h={}end;function m:close_func(a0)local a5=a0.L;local ai=a0.fs;local aM=ai.f;m:removevars(a0,0)p:ret(ai,0,0)aM.sizecode=ai.pc;aM.sizelineinfo=ai.pc;aM.sizek=ai.nk;aM.sizep=ai.np;aM.sizelocvars=ai.nlocvars;aM.sizeupvalues=aM.nups;assert(ai.bl==nil)a0.fs=ai.prev;if ai then m:anchor_token(a0)end end;function m:parser(a5,w,r)local bE={}bE.t={}bE.lookahead={}local bF={}bF.upvalues={}bF.actvar={}a5.nCcalls=0;bE.buff=r;o:setinput(a5,bE,w)m:open_func(bE,bF)bF.f.is_vararg=m.VARARG_ISVARARG;o:next(bE)m:chunk(bE)m:check(bE,"TK_EOS")m:close_func(bE)assert(bF.prev==nil)assert(bF.f.nups==0)assert(bE.fs==nil)return bF.f end;function m:field(a0,N)local ai=a0.fs;local aX={}p:exp2anyreg(ai,N)o:next(a0)m:checkname(a0,aX)p:indexed(ai,N,aX)end;function m:yindex(a0,N)o:next(a0)m:expr(a0,N)p:exp2val(a0.fs,N)m:checknext(a0,"]")end;function m:recfield(a0,bG)local ai=a0.fs;local aC=a0.fs.freereg;local aX,bH={},{}if a0.t.token=="TK_NAME"then m:checklimit(ai,bG.nh,m.MAX_INT,"items in a constructor")m:checkname(a0,aX)else m:yindex(a0,aX)end;bG.nh=bG.nh+1;m:checknext(a0,"=")local bI=p:exp2RK(ai,aX)m:expr(a0,bH)p:codeABC(ai,"OP_SETTABLE",bG.t.info,bI,p:exp2RK(ai,bH))ai.freereg=aC end;function m:closelistfield(ai,bG)if bG.v.k=="VVOID"then return end;p:exp2nextreg(ai,bG.v)bG.v.k="VVOID"if bG.tostore==n.LFIELDS_PER_FLUSH then p:setlist(ai,bG.t.info,bG.na,bG.tostore)bG.tostore=0 end end;function m:lastlistfield(ai,bG)if bG.tostore==0 then return end;if m:hasmultret(bG.v.k)then p:setmultret(ai,bG.v)p:setlist(ai,bG.t.info,bG.na,m.LUA_MULTRET)bG.na=bG.na-1 else if bG.v.k~="VVOID"then p:exp2nextreg(ai,bG.v)end;p:setlist(ai,bG.t.info,bG.na,bG.tostore)end end;function m:listfield(a0,bG)m:expr(a0,bG.v)m:checklimit(a0.fs,bG.na,m.MAX_INT,"items in a constructor")bG.na=bG.na+1;bG.tostore=bG.tostore+1 end;function m:constructor(a0,P)local ai=a0.fs;local b9=a0.linenumber;local au=p:codeABC(ai,"OP_NEWTABLE",0,0,0)local bG={}bG.v={}bG.na,bG.nh,bG.tostore=0,0,0;bG.t=P;m:init_exp(P,"VRELOCABLE",au)m:init_exp(bG.v,"VVOID",0)p:exp2nextreg(a0.fs,P)m:checknext(a0,"{")repeat assert(bG.v.k=="VVOID"or bG.tostore>0)if a0.t.token=="}"then break end;m:closelistfield(ai,bG)local D=a0.t.token;if D=="TK_NAME"then o:lookahead(a0)if a0.lookahead.token~="="then m:listfield(a0,bG)else m:recfield(a0,bG)end elseif D=="["then m:recfield(a0,bG)else m:listfield(a0,bG)end until not m:testnext(a0,",")and not m:testnext(a0,";")m:check_match(a0,"}","{",b9)m:lastlistfield(ai,bG)n:SETARG_B(ai.f.code[au],m:int2fb(bG.na))n:SETARG_C(ai.f.code[au],m:int2fb(bG.nh))end;function m:parlist(a0)local ai=a0.fs;local aM=ai.f;local bJ=0;aM.is_vararg=0;if a0.t.token~=")"then repeat local D=a0.t.token;if D=="TK_NAME"then m:new_localvar(a0,m:str_checkname(a0),bJ)bJ=bJ+1 elseif D=="TK_DOTS"then o:next(a0)m:new_localvarliteral(a0,"arg",bJ)bJ=bJ+1;aM.is_vararg=m.VARARG_HASARG+m.VARARG_NEEDSARG;aM.is_vararg=aM.is_vararg+m.VARARG_ISVARARG else o:syntaxerror(a0,"<name> or "..m:LUA_QL("...").." expected")end until aM.is_vararg~=0 or not m:testnext(a0,",")end;m:adjustlocalvars(a0,bJ)aM.numparams=ai.nactvar-aM.is_vararg%m.HASARG_MASK;p:reserveregs(ai,ai.nactvar)end;function m:body(a0,aj,bK,b9)local bL={}bL.upvalues={}bL.actvar={}m:open_func(a0,bL)bL.f.lineDefined=b9;m:checknext(a0,"(")if bK then m:new_localvarliteral(a0,"self",0)m:adjustlocalvars(a0,1)end;m:parlist(a0)m:checknext(a0,")")m:chunk(a0)bL.f.lastlinedefined=a0.linenumber;m:check_match(a0,"TK_END","TK_FUNCTION",b9)m:close_func(a0)m:pushclosure(a0,bL,aj)end;function m:explist1(a0,N)local x=1;m:expr(a0,N)while m:testnext(a0,",")do p:exp2nextreg(a0.fs,N)m:expr(a0,N)x=x+1 end;return x end;function m:funcargs(a0,aM)local ai=a0.fs;local bM={}local bJ;local b9=a0.linenumber;local D=a0.t.token;if D=="("then if b9~=a0.lastline then o:syntaxerror(a0,"ambiguous syntax (function call x new statement)")end;o:next(a0)if a0.t.token==")"then bM.k="VVOID"else m:explist1(a0,bM)p:setmultret(ai,bM)end;m:check_match(a0,")","(",b9)elseif D=="{"then m:constructor(a0,bM)elseif D=="TK_STRING"then m:codestring(a0,bM,a0.t.seminfo)o:next(a0)else o:syntaxerror(a0,"function arguments expected")return end;assert(aM.k=="VNONRELOC")local ba=aM.info;if m:hasmultret(bM.k)then bJ=m.LUA_MULTRET else if bM.k~="VVOID"then p:exp2nextreg(ai,bM)end;bJ=ai.freereg-(ba+1)end;m:init_exp(aM,"VCALL",p:codeABC(ai,"OP_CALL",ba,bJ+1,2))p:fixline(ai,b9)ai.freereg=ba+1 end;function m:prefixexp(a0,N)local D=a0.t.token;if D=="("then local b9=a0.linenumber;o:next(a0)m:expr(a0,N)m:check_match(a0,")","(",b9)p:dischargevars(a0.fs,N)elseif D=="TK_NAME"then m:singlevar(a0,N)else o:syntaxerror(a0,"unexpected symbol")end;return end;function m:primaryexp(a0,N)local ai=a0.fs;m:prefixexp(a0,N)while true do local D=a0.t.token;if D=="."then m:field(a0,N)elseif D=="["then local aX={}p:exp2anyreg(ai,N)m:yindex(a0,aX)p:indexed(ai,N,aX)elseif D==":"then local aX={}o:next(a0)m:checkname(a0,aX)p:_self(ai,N,aX)m:funcargs(a0,N)elseif D=="("or D=="TK_STRING"or D=="{"then p:exp2nextreg(ai,N)m:funcargs(a0,N)else return end end end;function m:simpleexp(a0,N)local D=a0.t.token;if D=="TK_NUMBER"then m:init_exp(N,"VKNUM",0)N.nval=a0.t.seminfo elseif D=="TK_STRING"then m:codestring(a0,N,a0.t.seminfo)elseif D=="TK_NIL"then m:init_exp(N,"VNIL",0)elseif D=="TK_TRUE"then m:init_exp(N,"VTRUE",0)elseif D=="TK_FALSE"then m:init_exp(N,"VFALSE",0)elseif D=="TK_DOTS"then local ai=a0.fs;m:check_condition(a0,ai.f.is_vararg~=0,"cannot use "..m:LUA_QL("...").." outside a vararg function")local bN=ai.f.is_vararg;if bN>=m.VARARG_NEEDSARG then ai.f.is_vararg=bN-m.VARARG_NEEDSARG end;m:init_exp(N,"VVARARG",p:codeABC(ai,"OP_VARARG",0,1,0))elseif D=="{"then m:constructor(a0,N)return elseif D=="TK_FUNCTION"then o:next(a0)m:body(a0,N,false,a0.linenumber)return else m:primaryexp(a0,N)return end;o:next(a0)end;function m:getunopr(L)if L=="TK_NOT"then return"OPR_NOT"elseif L=="-"then return"OPR_MINUS"elseif L=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;m.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function m:getbinopr(L)local bO=m.getbinopr_table[L]if bO then return bO else return"OPR_NOBINOPR"end end;m.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}m.UNARY_PRIORITY=8;function m:subexpr(a0,N,bq)m:enterlevel(a0)local bP=m:getunopr(a0.t.token)if bP~="OPR_NOUNOPR"then o:next(a0)m:subexpr(a0,N,m.UNARY_PRIORITY)p:prefix(a0.fs,bP,N)else m:simpleexp(a0,N)end;local L=m:getbinopr(a0.t.token)while L~="OPR_NOBINOPR"and m.priority[p.BinOpr[L]+1][1]>bq do local b3={}o:next(a0)p:infix(a0.fs,L,N)local bQ=m:subexpr(a0,b3,m.priority[p.BinOpr[L]+1][2])p:posfix(a0.fs,L,N,b3)L=bQ end;m:leavelevel(a0)return L end;function m:expr(a0,N)m:subexpr(a0,N,0)end;function m:block_follow(a1)if a1=="TK_ELSE"or a1=="TK_ELSEIF"or a1=="TK_END"or a1=="TK_UNTIL"or a1=="TK_EOS"then return true else return false end end;function m:block(a0)local ai=a0.fs;local bA={}m:enterblock(ai,bA,false)m:chunk(a0)assert(bA.breaklist==p.NO_JUMP)m:leaveblock(ai)end;function m:check_conflict(a0,bR,N)local ai=a0.fs;local bC=ai.freereg;local bS=false;while bR do if bR.v.k=="VINDEXED"then if bR.v.info==N.info then bS=true;bR.v.info=bC end;if bR.v.aux==N.info then bS=true;bR.v.aux=bC end end;bR=bR.prev end;if bS then p:codeABC(ai,"OP_MOVE",ai.freereg,N.info,0)p:reserveregs(ai,1)end end;function m:assignment(a0,bR,bw)local aj={}local D=bR.v.k;m:check_condition(a0,D=="VLOCAL"or D=="VUPVAL"or D=="VGLOBAL"or D=="VINDEXED","syntax error")if m:testnext(a0,",")then local bT={}bT.v={}bT.prev=bR;m:primaryexp(a0,bT.v)if bT.v.k=="VLOCAL"then m:check_conflict(a0,bR,bT.v)end;m:checklimit(a0.fs,bw,m.LUAI_MAXCCALLS-a0.L.nCcalls,"variables in assignment")m:assignment(a0,bT,bw+1)else m:checknext(a0,"=")local bB=m:explist1(a0,aj)if bB~=bw then m:adjust_assign(a0,bw,bB,aj)if bB>bw then a0.fs.freereg=a0.fs.freereg-(bB-bw)end else p:setoneret(a0.fs,aj)p:storevar(a0.fs,bR.v,aj)return end end;m:init_exp(aj,"VNONRELOC",a0.fs.freereg-1)p:storevar(a0.fs,bR.v,aj)end;function m:cond(a0)local N={}m:expr(a0,N)if N.k=="VNIL"then N.k="VFALSE"end;p:goiftrue(a0.fs,N)return N.f end;function m:breakstat(a0)local ai=a0.fs;local bA=ai.bl;local bU=false;while bA and not bA.isbreakable do if bA.upval then bU=true end;bA=bA.previous end;if not bA then o:syntaxerror(a0,"no loop to break")end;if bU then p:codeABC(ai,"OP_CLOSE",bA.nactvar,0,0)end;bA.breaklist=p:concat(ai,bA.breaklist,p:jump(ai))end;function m:whilestat(a0,b9)local ai=a0.fs;local bA={}o:next(a0)local bV=p:getlabel(ai)local bW=m:cond(a0)m:enterblock(ai,bA,true)m:checknext(a0,"TK_DO")m:block(a0)p:patchlist(ai,p:jump(ai),bV)m:check_match(a0,"TK_END","TK_WHILE",b9)m:leaveblock(ai)p:patchtohere(ai,bW)end;function m:repeatstat(a0,b9)local ai=a0.fs;local bX=p:getlabel(ai)local bY,bZ={},{}m:enterblock(ai,bY,true)m:enterblock(ai,bZ,false)o:next(a0)m:chunk(a0)m:check_match(a0,"TK_UNTIL","TK_REPEAT",b9)local bW=m:cond(a0)if not bZ.upval then m:leaveblock(ai)p:patchlist(a0.fs,bW,bX)else m:breakstat(a0)p:patchtohere(a0.fs,bW)m:leaveblock(ai)p:patchlist(a0.fs,p:jump(ai),bX)end;m:leaveblock(ai)end;function m:exp1(a0)local aj={}m:expr(a0,aj)local aK=aj.k;p:exp2nextreg(a0.fs,aj)return aK end;function m:forbody(a0,ba,b9,bw,b_)local bA={}local ai=a0.fs;m:adjustlocalvars(a0,3)m:checknext(a0,"TK_DO")local c0=b_ and p:codeAsBx(ai,"OP_FORPREP",ba,p.NO_JUMP)or p:jump(ai)m:enterblock(ai,bA,false)m:adjustlocalvars(a0,bw)p:reserveregs(ai,bw)m:block(a0)m:leaveblock(ai)p:patchtohere(ai,c0)local c1=b_ and p:codeAsBx(ai,"OP_FORLOOP",ba,p.NO_JUMP)or p:codeABC(ai,"OP_TFORLOOP",ba,0,bw)p:fixline(ai,b9)p:patchlist(ai,b_ and c1 or p:jump(ai),c0+1)end;function m:fornum(a0,bu,b9)local ai=a0.fs;local ba=ai.freereg;m:new_localvarliteral(a0,"(for index)",0)m:new_localvarliteral(a0,"(for limit)",1)m:new_localvarliteral(a0,"(for step)",2)m:new_localvar(a0,bu,3)m:checknext(a0,'=')m:exp1(a0)m:checknext(a0,",")m:exp1(a0)if m:testnext(a0,",")then m:exp1(a0)else p:codeABx(ai,"OP_LOADK",ai.freereg,p:numberK(ai,1))p:reserveregs(ai,1)end;m:forbody(a0,ba,b9,1,true)end;function m:forlist(a0,c2)local ai=a0.fs;local aj={}local bw=0;local ba=ai.freereg;m:new_localvarliteral(a0,"(for generator)",bw)bw=bw+1;m:new_localvarliteral(a0,"(for state)",bw)bw=bw+1;m:new_localvarliteral(a0,"(for control)",bw)bw=bw+1;m:new_localvar(a0,c2,bw)bw=bw+1;while m:testnext(a0,",")do m:new_localvar(a0,m:str_checkname(a0),bw)bw=bw+1 end;m:checknext(a0,"TK_IN")local b9=a0.linenumber;m:adjust_assign(a0,3,m:explist1(a0,aj),aj)p:checkstack(ai,3)m:forbody(a0,ba,b9,bw-3,false)end;function m:forstat(a0,b9)local ai=a0.fs;local bA={}m:enterblock(ai,bA,true)o:next(a0)local bu=m:str_checkname(a0)local D=a0.t.token;if D=="="then m:fornum(a0,bu,b9)elseif D==","or D=="TK_IN"then m:forlist(a0,bu)else o:syntaxerror(a0,m:LUA_QL("=").." or "..m:LUA_QL("in").." expected")end;m:check_match(a0,"TK_END","TK_FOR",b9)m:leaveblock(ai)end;function m:test_then_block(a0)o:next(a0)local bW=m:cond(a0)m:checknext(a0,"TK_THEN")m:block(a0)return bW end;function m:ifstat(a0,b9)local ai=a0.fs;local c3=p.NO_JUMP;local c4=m:test_then_block(a0)while a0.t.token=="TK_ELSEIF"do c3=p:concat(ai,c3,p:jump(ai))p:patchtohere(ai,c4)c4=m:test_then_block(a0)end;if a0.t.token=="TK_ELSE"then c3=p:concat(ai,c3,p:jump(ai))p:patchtohere(ai,c4)o:next(a0)m:block(a0)else c3=p:concat(ai,c3,c4)end;p:patchtohere(ai,c3)m:check_match(a0,"TK_END","TK_IF",b9)end;function m:localfunc(a0)local N,s={},{}local ai=a0.fs;m:new_localvar(a0,m:str_checkname(a0),0)m:init_exp(N,"VLOCAL",ai.freereg)p:reserveregs(ai,1)m:adjustlocalvars(a0,1)m:body(a0,s,false,a0.linenumber)p:storevar(ai,N,s)m:getlocvar(ai,ai.nactvar-1).startpc=ai.pc end;function m:localstat(a0)local bw=0;local bB;local aj={}repeat m:new_localvar(a0,m:str_checkname(a0),bw)bw=bw+1 until not m:testnext(a0,",")if m:testnext(a0,"=")then bB=m:explist1(a0,aj)else aj.k="VVOID"bB=0 end;m:adjust_assign(a0,bw,bB,aj)m:adjustlocalvars(a0,bw)end;function m:funcname(a0,N)local bK=false;m:singlevar(a0,N)while a0.t.token=="."do m:field(a0,N)end;if a0.t.token==":"then bK=true;m:field(a0,N)end;return bK end;function m:funcstat(a0,b9)local N,s={},{}o:next(a0)local bK=m:funcname(a0,N)m:body(a0,s,bK,b9)p:storevar(a0.fs,N,s)p:fixline(a0.fs,b9)end;function m:exprstat(a0)local ai=a0.fs;local N={}N.v={}m:primaryexp(a0,N.v)if N.v.k=="VCALL"then n:SETARG_C(p:getcode(ai,N.v),1)else N.prev=nil;m:assignment(a0,N,1)end end;function m:retstat(a0)local ai=a0.fs;local aj={}local Y,ar;o:next(a0)if m:block_follow(a0.t.token)or a0.t.token==";"then Y,ar=0,0 else ar=m:explist1(a0,aj)if m:hasmultret(aj.k)then p:setmultret(ai,aj)if aj.k=="VCALL"and ar==1 then n:SET_OPCODE(p:getcode(ai,aj),"OP_TAILCALL")assert(n:GETARG_A(p:getcode(ai,aj))==ai.nactvar)end;Y=ai.nactvar;ar=m.LUA_MULTRET else if ar==1 then Y=p:exp2anyreg(ai,aj)else p:exp2nextreg(ai,aj)Y=ai.nactvar;assert(ar==ai.freereg-Y)end end end;p:ret(ai,Y,ar)end;function m:statement(a0)local b9=a0.linenumber;local D=a0.t.token;if D=="TK_IF"then m:ifstat(a0,b9)return false elseif D=="TK_WHILE"then m:whilestat(a0,b9)return false elseif D=="TK_DO"then o:next(a0)m:block(a0)m:check_match(a0,"TK_END","TK_DO",b9)return false elseif D=="TK_FOR"then m:forstat(a0,b9)return false elseif D=="TK_REPEAT"then m:repeatstat(a0,b9)return false elseif D=="TK_FUNCTION"then m:funcstat(a0,b9)return false elseif D=="TK_LOCAL"then o:next(a0)if m:testnext(a0,"TK_FUNCTION")then m:localfunc(a0)else m:localstat(a0)end;return false elseif D=="TK_RETURN"then m:retstat(a0)return true elseif D=="TK_BREAK"then o:next(a0)m:breakstat(a0)return true else m:exprstat(a0)return false end end;function m:chunk(a0)local c5=false;m:enterlevel(a0)while not c5 and not m:block_follow(a0.t.token)do c5=m:statement(a0)m:testnext(a0,";")assert(a0.fs.f.maxstacksize>=a0.fs.freereg and a0.fs.freereg>=a0.fs.nactvar)a0.fs.freereg=a0.fs.nactvar end;m:leavelevel(a0)end;o:init()local c6={}return function(U,c7)local aM,bd,r,v;local c8,c9=pcall(function()local ca=l:init(l:make_getS(U),nil)if not ca then return error()end;local aY=m:parser(c6,ca,nil)bd,r=q:make_setS()q:dump(c6,aY,bd,r)end)if c8 then return r.data else return c9 end end
